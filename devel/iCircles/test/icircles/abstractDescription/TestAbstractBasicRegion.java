package icircles.abstractDescription;

import java.util.ArrayList;
import java.util.TreeSet;

import org.junit.*;
import org.junit.runner.RunWith;
import static org.junit.Assert.*;
import org.jcheck.*;
import org.jcheck.annotations.Configuration;
import org.jcheck.annotations.Generator;

@RunWith(org.jcheck.runners.JCheckRunner.class)
public class TestAbstractBasicRegion {

	/**
	 * Tests the get method of @see AbstractBasicRegion
	 * 
	 * Creates two @see AbstractBasicRegion from the same @see AbstractCurve set
	 * then compares to ensure they're equal.  Then remove one AbstractCurve from
	 * one AbstractBasicRegion and recompare for inequality.
	 * 
	 * @author Aidan Delaney <aidan@phoric.eu>
	 * @param acs The arbitrary length (<= 20) array of arbitrary @see AbstractCurve objects generated by JCheck
	 */
    @Test
    @Configuration(tests=100, size=20) //limit the AbstractCurve[] to be lower than 20 elements 
    @Generator(klass=AbstractCurve.class, generator=CustomAbstractCurveGen.class)
	public void testGet(AbstractCurve[] acs) {
    	if(0 == acs.length) {
    		assertTrue(true);
    		return;
    	}
    	
    	TreeSet<AbstractCurve> in_set = new TreeSet<AbstractCurve>();
    	
    	for(AbstractCurve ac : acs) {
    		in_set.add(ac);
    	}
    	
    	AbstractBasicRegion abr1 = AbstractBasicRegion.get(in_set);
    	
    	for(AbstractCurve ac : acs) {
    		in_set.add(ac);
    	}
    	
    	AbstractBasicRegion abr2 = AbstractBasicRegion.get(in_set);
    	
		assertEquals(abr1, abr2);
		// get one of the AbstractCurves on the outside
		try {
			AbstractCurve first = in_set.first(); 
		abr2 = abr2.moveOutside(first);
		} catch (Exception e) {
			System.out.println(in_set.first().journalString());
		}
		assertFalse("abr1: " + abr1.journalString() + "\nabr2: " + abr2.journalString() , abr1.equals(abr2));
	}
	
	@Test
	@Configuration(tests=100, size=20) //limit the AbstractCurve[] to be lower than 20 elements 
    @Generator(klass=AbstractCurve.class, generator=CustomAbstractCurveGen.class)
	public void testMoveOutside(AbstractCurve[] acs) {
    	if(0 == acs.length) {
    		assertTrue(true);
    		return;
    	}
    	
		TreeSet<AbstractCurve> in_set = new TreeSet<AbstractCurve>();
    	
    	for(AbstractCurve ac : acs) {
    		in_set.add(ac);
    	}
    	
    	AbstractBasicRegion abr1 = AbstractBasicRegion.get(in_set);
    	
    	AbstractCurve first = in_set.first();
		assertEquals(abr1, abr1.moveOutside(first).moved_in(first));
	}
/*	
	@Test
	public void testCompareTo() {
		assertTrue(false);
	}
	
	@Test
	public void testGetStraddledContour() {
		assertTrue(false);
	}
	
	@Test
	public void testMoved_in() {
		assertTrue(false);
	}
	
	@Test
	public void testIsLabelEquivalent() {
		assertTrue(false);
	}
	*/
}